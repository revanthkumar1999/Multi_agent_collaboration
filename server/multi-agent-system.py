"""
Multi-agent system implementation for the chatbot
"""
import traceback
from langgraph.checkpoint.memory import InMemorySaver
from langgraph_swarm import create_handoff_tool, create_swarm
from langchain_core.tools import tool

from server.agents import (
    get_project_manager_agent,
    get_software_engineer_agent,
    get_data_engineer_agent,
    get_qa_tester_agent,
    get_deployment_engineer_agent
)

from server.utils import (
    process_and_execute_sql_query,
    push_md_to_github_with_auto_numbering,
    build_table_string
)

def setup_swarm():
    """
    Set up and configure the multi-agent swarm
    
    Returns:
        The configured swarm object
    """
    # Define handoff tools for agent transfers
    transfer_to_project_manager = create_handoff_tool(
        agent_name="project_manager",
        description="Transfer to the project manager to break down the task as per the user request.",
    )

    transfer_to_software_engineer = create_handoff_tool(
        agent_name="software_engineer",
        description="Transfer to the software engineer to generate python code.",
    )

    transfer_to_qa_tester = create_handoff_tool(
        agent_name="qa_tester",
        description="Transfer to the tester for generating the assert test code in python.",
    )

    transfer_to_data_engineer = create_handoff_tool(
        agent_name="data_engineer",
        description="Transfer to the data engineer to generate sql or if any sql, metrics and data related queries is asked by the user",
    )

    transfer_to_deployment_engineer = create_handoff_tool(
        agent_name="deployment_engineer",
        description="Transfer to the deployment engineer to generate documentation for the Python functions.",
    )
    
    # Define the SQL execution tool
    @tool
    def execute_sql(data):
        """Execute the SQL query generated by the data engineer agent"""
        if not data or 'query' not in data:
            return {"error": "No SQL query provided"}

        sql_query = data['query']
        print(f"Executing SQL: {sql_query}")

        return process_and_execute_sql_query({"query": sql_query})
    
    # Create the agents with their respective tools
    project_manager = get_project_manager_agent([
        transfer_to_software_engineer, 
        transfer_to_data_engineer, 
        transfer_to_qa_tester, 
        transfer_to_deployment_engineer
    ])

    software_engineer = get_software_engineer_agent([
        transfer_to_qa_tester,
        transfer_to_data_engineer
    ])

    data_engineer = get_data_engineer_agent([
        transfer_to_project_manager,
        execute_sql
    ])

    qa_tester = get_qa_tester_agent([
        transfer_to_deployment_engineer
    ])

    deployment_engineer = get_deployment_engineer_agent([
        transfer_to_project_manager,
        transfer_to_data_engineer
    ])

    # Create and compile the swarm
    checkpointer = InMemorySaver()
    builder = create_swarm(
        [project_manager, software_engineer, data_engineer, qa_tester, deployment_engineer],
        default_active_agent="project_manager"
    )

    # Compile and return the swarm
    swarm = builder.compile(checkpointer=checkpointer)
    return swarm

def process_query(swarm, query, user_id, thread_id, agent_outputs=None):
    """
    Process a query through the agent swarm system and return only the last message
    from the appropriate agent.

    Parameters:
        swarm: The swarm object containing the agent system
        query (str): The user's query text
        user_id (str): Unique identifier for the user
        thread_id (str): Unique identifier for the conversation thread
        agent_outputs (dict): Dictionary to store outputs from different agents

    Returns:
        tuple: (formatted_response, updated_agent_outputs)
    """
    agent_type = ''
    try:
        # Initialize agent_outputs dictionary if not already done
        if agent_outputs is None:
            agent_outputs = {}

        # Determine which agent to use based on keywords in the query
        if "project" in query.lower():
            res = swarm.invoke(
                {"messages": [{"role": "user", "content": query}]},
                {"configurable": {"thread_id": thread_id, "user_id": user_id}, "recursion_limit": 100},
            )
            agent_type = 'pm'
            agent_outputs['pm'] = ""

        elif "software" in query.lower():
            # Use project manager output if available
            combined_input = query
            if 'pm' in agent_outputs and agent_outputs['pm']:
                combined_input = str(agent_outputs['pm']) + " " + query

            res = swarm.invoke(
                {"messages": [{"role": "user", "content": combined_input}]},
                {"configurable": {"thread_id": thread_id, "user_id": user_id}, "recursion_limit": 100},
            )
            agent_type = 'se'

        elif "tester" in query.lower():
            # Use software engineer output if available
            combined_input = query
            if 'se' in agent_outputs and agent_outputs['se']:
                combined_input = str(agent_outputs['se']) + " " + query

            res = swarm.invoke(
                {"messages": [{"role": "user", "content": combined_input}]},
                {"configurable": {"thread_id": thread_id, "user_id": user_id}, "recursion_limit": 100},
            )
            agent_type = 'qa'

        elif "deployment" in query.lower():
            # Use software engineer output if available
            combined_input = query
            if 'se' in agent_outputs and agent_outputs['se']:
                combined_input = str(agent_outputs['se']) + " " + query

            res = swarm.invoke(
                {"messages": [{"role": "user", "content": combined_input}]},
                {"configurable": {"thread_id": thread_id, "user_id": user_id}, "recursion_limit": 100},
            )
            agent_type = 'dp'

        else:
            # Default to data engineer for other queries
            res = swarm.invoke(
                {"messages": [{"role": "user", "content": query}]},
                {"configurable": {"thread_id": thread_id, "user_id": user_id}, "recursion_limit": 100},
            )
            agent_type = 'de'

        print(f"Full message: {res}")

        # Get messages from the response
        messages = res.get('messages', [])

        # Initialize variables to track the last message
        last_agent_message = None
        last_agent_name = None
        dp_final = [""] * 100
        count = 0
        
        # Skip the first message which is the user query
        for i, message in enumerate(messages[1:], 1):
            if isinstance(message, dict):
                # Extract relevant information
                msg_type = message.get('type')
                msg_name = message.get('name', '')
                msg_content = message.get('content', '')

                # Keep track of AI messages
                if msg_type == "ai" and msg_name and msg_content:
                    # Update the last message
                    last_agent_message = msg_content
                    last_agent_name = msg_name
            else:
                # Handle objects with attributes
                if hasattr(message, 'type') and message.type == "ai":
                    if hasattr(message, 'name') and hasattr(message, 'content') and message.content:
                        # Update the last message
                        last_agent_message = message.content
                        last_agent_name = message.name

                        # Store agent outputs based on the agent type
                        if agent_type == 'dp':
                            print("Deployment documentation to GitHub")
                            dp_final[count] += "\n\n" + message.content + "\n\n"
                            agent_outputs = {}  # Reset agent outputs after deployment

                        elif agent_type == 'se':
                            agent_outputs['se'] = message.content

                        elif agent_type == 'qa':
                            agent_outputs['qa'] = message.content

                        elif agent_type == 'pm':
                            agent_outputs['pm'] = message.content

                        elif agent_type == 'de':
                            agent_outputs['de'] = message.content

        # Format only the last message
        formatted_response = ""
        if last_agent_message and last_agent_name:
            formatted_response = f"Agent: {last_agent_name.replace('_', ' ').upper()}\n\n{last_agent_message}"

            # Handle special case for data engineer - execute SQL and add results
            if agent_type == 'de':
                result = process_and_execute_sql_query(last_agent_message)
                if result["status"] == "success":
                    table_str = build_table_string(result['data'], result['column_names'])
                    formatted_response += f"\n\n```\n{table_str}\n```"
            elif agent_type == 'dp':
                if count > 0:
                    dp_final[count] = dp_final[count].replace(dp_final[count - 1], "")
                push_md_to_github_with_auto_numbering(
                    content=dp_final[count],
                    commit_message="Daily Status Commits"
                )
                count += 1

        return formatted_response, agent_outputs

    except Exception as e:
        print(f"Error in process_query: {str(e)}")
        traceback.print_exc()
        return f"Error processing your request: {str(e)}", agent_outputs if 'agent_outputs' in locals() else {}
